// Generated by CoffeeScript 1.12.5
var argreader, args, inspect, latestParsed, options, readArgs, replaceOptions,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

args = exports.args = process.argv.slice(2);

inspect = require("util").inspect;

exports.rawArgs = process.argv;

exports.latestParsed = latestParsed = [];

argreader = require("./arg-reader");

readArgs = [];

options = require("./options");

replaceOptions = function(message, arg, type) {
  var usedmsg;
  if (message == null) {
    message = 0;
  }
  switch (message) {
    case 0:
      usedmsg = options.notFoundStr || "Invalid argument {arg}!";
      break;
    case 1:
      usedmsg = options.invalidType || "The argument {arg} requires the type {type}!";
      break;
    case 2:
      usedmsg = options.repeatedArg || "The argument {arg} was already used!";
      break;
    case 3:
      usedmsg = options.emptyArgErr || "The argument {arg} must not be empty!";
      break;
    default:
      throw new RangeError("Invalid message type.");
  }
  return usedmsg.replace(/{arg}/g, arg).replace(/{type}/g, type);
};

exports.setArgs = function() {
  var argz;
  argz = Array.from(arguments);
  return argz.forEach(function(arg) {
    var index, readarg;
    readarg = argreader(arg);
    index = null;
    readArgs.forEach(function(ah, i) {
      if (ah.name && ah.name === arg.name) {
        return index = i;
      }
    });
    if (index != null) {
      return readArgs[index] = readarg;
    } else {
      return readArgs.push(readarg);
    }
  });
};

exports.setOptions = function() {
  var argz, indexPair, latestIndex, pairedArr;
  argz = Array.from(arguments);
  latestIndex = 0;
  indexPair = 0;
  pairedArr = [[]];
  argz.forEach(function(arg, i) {
    if (indexPair === 1) {
      indexPair = 0;
      pairedArr[latestIndex++].push(arg);
      if (argz[i + 1]) {
        return pairedArr.push([]);
      }
    } else {
      indexPair = 1;
      return pairedArr[latestIndex].push(arg);
    }
  });
  if (pairedArr[pairedArr.length - 1].length < 2) {
    throw new RangeError("Must give value for option!");
  }
  pairedArr.forEach(function(arg1) {
    var option, value;
    option = arg1[0], value = arg1[1];
    if (indexOf.call(Object.keys(options), option) >= 0) {
      return options[option] = value;
    } else {
      throw new TypeError("Invalid option: " + option + "!");
    }
  });
  return true;
};

exports.parseArgs = function() {
  var ignore, parsedArgs;
  parsedArgs = {};
  ignore = false;
  args.forEach(function(arg, i) {
    var actualval, argval, nextarg, prefix, valid;
    if (ignore) {
      return ignore = false;
    }
    if (arg.startsWith("--") || arg.startsWith("-")) {
      prefix = arg.startsWith("--") ? "name" : "shortcut";
      argval = arg.replace(/^--?/, "");
      valid = false;
      nextarg = argval.replace(/^[^=]+=?/, "");
      if (!nextarg && args[i + 1] && !args[i + 1].startsWith("-")) {
        nextarg = args[i + 1];
        ignore = true;
        actualval = argval;
      } else {
        actualval = argval.match(/^([^=]+)=?/)[1];
      }
      readArgs.forEach(function(readArg) {
        var argname, argshort, caseSensitive, isFullName, isShortName, separatedPath, setNull;
        caseSensitive = !!options.caseSensitive;
        argname = readArg.name;
        argshort = readArg.shortcut || null;
        if (!caseSensitive) {
          isFullName = actualval.toLowerCase() === argname.toLowerCase();
          if (argshort) {
            isShortName = actualval.toLowerCase() === argshort.toLowerCase();
          } else {
            isShortName = false;
          }
        } else {
          isFullName = actualval === argname;
          if (argshort) {
            isShortName = actualval === argshort;
          } else {
            isShortName = false;
          }
        }
        setNull = function() {
          return parsedArgs[argname] = null;
        };
        if ((prefix === "name" && isFullName) || (prefix === "shortcut" && isShortName)) {
          valid = true;
          if (parsedArgs[argname] && !readArg.multiple) {
            if (options.strict) {
              throw new Error(replaceOptions(2, argname));
            } else {
              return setNull();
            }
          }
          if (nextarg) {
            switch (readArg.type) {
              case "string":
                return parsedArgs[argname] = nextarg;
              case "number":
                if (isNaN(nextarg)) {
                  if (options.strict) {
                    throw new TypeError(replaceOptions(1, argname, readArg.type));
                  } else {
                    return setNull();
                  }
                }
                return parsedArgs[argname] = +nextarg;
              case "boolean":
                if (/^(?:yes|true|1)$/.test(nextarg)) {
                  return parsedArgs[argname] = true;
                } else if (/^(?:no|false|0)$/.test(nextarg)) {
                  return parsedArgs[argname] = false;
                } else {
                  return parsedArgs[argname] = true;
                }
                break;
              case "path":
                if (!/\/|\\/.test(nextarg)) {
                  if (options.strict) {
                    throw new TypeError(replaceOptions(1, argname, readArg.type));
                  } else {
                    return setNull();
                  }
                }
                separatedPath = nextarg.split(/\/|\\/);
                return parsedArgs[argname] = separatedPath.join(options.pathSymbol || "/");
              case "array":
                return parsedArgs[argname] = nextarg.split(options.arraySymbol || ",");
              default:
                throw new RangeError("Invalid type " + readArg.type + "!");
            }
          } else if (readArg.allowEmpty) {
            switch (readArg.type) {
              case "string":
              case "path":
                return parsedArgs[argname] = "";
              case "number":
                return parsedArgs[argname] = 0/0;
              case "boolean":
                return parsedArgs[argname] = true;
              case "array":
                return parsedArgs[argname] = [];
              default:
                throw new RangeError("Invalid type " + readArg.type + "!");
            }
          } else {
            if (options.strict) {
              return replaceOptions(3, argname);
            } else {
              return setNull();
            }
          }
        }
      });
      if ((!valid) && options.strict) {
        throw new TypeError(replaceOptions(0, arg));
      } else {
        return void 0;
      }
    }
  });
  if (latestParsed.length >= (isNaN(options.parseCache) ? 1 : options.parseCache)) {
    latestParsed.pop();
    latestParsed.unshift(parsedArgs);
  } else {
    latestParsed.push(parsedArgs);
  }
  return parsedArgs;
};
